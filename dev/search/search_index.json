{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Fractal Converters Tools","text":"<p>Fractal Converters Tools is a Python package that provides tooling for building OME-Zarr converters for the Fractal platform.</p> <p>It includes three main components:</p> <ol> <li>Abstraction layer for mapping the on-disk raw data to Image objects</li> <li>Common tooling to build converters as Fractal Compound Tasks</li> </ol>"},{"location":"#main-concepts","title":"Main Concepts","text":"<p>In general a single microscopy image is not acquired in a single big array in a single file, but rather in multiple smaller tiles. How atomic these tiles are depends on the specific microscope and the acquisition settings.</p> <p>To make building converters easier, Fractal Converters Tools provides an abstraction layer that allows you to map these on-disk raw data to an Image object which we call <code>Tile</code>.</p> <p>Moreover, usually a single microscopy image is not composed of a single tile, but rather multiple tiles that are stitched together to form a complete image. We call these objects <code>TiledImage</code>.</p> <pre><code>flowchart LR\n    subgraph A[Metadata Parsing]\n    A100[img_B3_fov1_c0_z0.tif] --&gt; B1[Tile1]\n    A101[img_B3_fov1_c0_z1.tif] --&gt; B1\n    A200[img_B3_fov2_c0_z0.tif] --&gt; B2[Tile2]\n    A201[img_B3_fov2_c0_z1.tif] --&gt; B2\n    A20x[img_...] --&gt; B3[Tile...]\n\n    B1 --&gt; C1[TiledImage1]\n    B2 --&gt; C1\n\n    B3 --&gt; C2[TiledImage2]\n    end\n\n    C1 --&gt; D[Init - Task]\n    C2 --&gt;|\"Many...\"| D\n    D --&gt; E[Compute Tile1]\n    D --&gt; E1[Compute Tile2]\n    D --&gt;|Many...| E2[Compute ...]</code></pre> <p>Additional Fractal Converters Tools supports high-content screening HCS applications. In the context of HCS it is common to have multiple images that are related to each other in a single plate collection. Plates are standardized in OME-Zarr and Fractal Converters Tools provides the necessary tools to correctly place the images in a plate collection.</p>"},{"location":"#installation","title":"Installation","text":"<p>To get started with Fractal Converters Tools, you can install it via pip:</p> <pre><code>pip install fractal-converters-tools\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\nimport pandas as pd\n\ntiles_meta = pd.read_csv(\"../tests/hiPSC_Tiny/tiles.csv\")\ntiles_meta\n</pre> %load_ext autoreload %autoreload 2 import pandas as pd  tiles_meta = pd.read_csv(\"../tests/hiPSC_Tiny/tiles.csv\") tiles_meta Out[1]: path row column acquisition_id fov channel z t pos_x pos_y shape_x shape_y 0 20200812-CardiomyocyteDifferentiation14-Cycle1... B 3 0 1 0 0 0 -1448.3 1517.7 2560 2160 1 20200812-CardiomyocyteDifferentiation14-Cycle1... B 3 0 1 0 1 0 -1448.3 1517.7 2560 2160 2 20200812-CardiomyocyteDifferentiation14-Cycle1... B 3 0 2 0 0 0 -1032.3 1517.7 2560 2160 3 20200812-CardiomyocyteDifferentiation14-Cycle1... B 3 0 2 0 1 0 -1032.3 1517.7 2560 2160 In\u00a0[2]: Copied! <pre>import json\nfrom pprint import pprint\n\nwith open(\"../tests/hiPSC_Tiny/metadata.json\") as f:\n    metadata = json.load(f)\n\npprint(metadata)\n</pre> import json from pprint import pprint  with open(\"../tests/hiPSC_Tiny/metadata.json\") as f:     metadata = json.load(f)  pprint(metadata) <pre>{'channel_names': ['DAPI'],\n 'pixel_size': {'t': 1.0, 'x': 0.1625, 'y': 0.1625, 'z': 0.5},\n 'plate_name': 'hiPSC_Tiny',\n 'wavelength_ids': ['DAPI']}\n</pre> In\u00a0[3]: Copied! <pre>from fractal_converters_tools import PlatePathBuilder, TiledImage\n\ntiled_image = TiledImage(\n    name=f\"{metadata.get('plate_name')}_B3_0\",\n    path_builder=PlatePathBuilder(\n        plate_name=metadata.get(\"plate_name\"),\n        row=\"B\",\n        column=3,\n        acquisition_id=0,\n    ),  # you can also use the SimplePathBuilder if the data is not path of a plate\n    channel_names=metadata.get(\"channel_names\", []),\n    wavelength_ids=metadata.get(\"wavelength_ids\", []),\n)\ntiled_image\n</pre> from fractal_converters_tools import PlatePathBuilder, TiledImage  tiled_image = TiledImage(     name=f\"{metadata.get('plate_name')}_B3_0\",     path_builder=PlatePathBuilder(         plate_name=metadata.get(\"plate_name\"),         row=\"B\",         column=3,         acquisition_id=0,     ),  # you can also use the SimplePathBuilder if the data is not path of a plate     channel_names=metadata.get(\"channel_names\", []),     wavelength_ids=metadata.get(\"wavelength_ids\", []), ) tiled_image Out[3]: <pre>TiledImage(name=hiPSC_Tiny_B3_0, path=hiPSC_Tiny.zarr/B/3/0)</pre> In\u00a0[4]: Copied! <pre>import numpy as np\nimport PIL.Image\n\n\nclass PngLoader:\n    \"\"\"Png loader for tiled images.\"\"\"\n\n    def __init__(self, dir: str, paths: list[str]):\n        \"\"\"Initialize the PngLoader.\n\n        Args:\n            dir (str): Directory where the PNG files are located.\n            paths (list[str]): List of PNG file paths relative to the directory.\n        \"\"\"\n        self.dir = dir\n        self.paths = paths\n\n    def load(self) -&gt; np.ndarray:\n        \"\"\"Load the PNG files and stack them into a numpy array.\"\"\"\n        arrays = []\n        for path in self.paths:\n            full_path = f\"{self.dir}/{path}\"\n            img = PIL.Image.open(full_path)\n            arrays.append(np.array(img))\n        stacked_arrays = np.stack(arrays, axis=0)[None, None, :, :, :]\n        return stacked_arrays\n\n    @property\n    def dtype(self):\n        \"\"\"Return the data type of the loaded images.\"\"\"\n        return \"uint8\"\n</pre> import numpy as np import PIL.Image   class PngLoader:     \"\"\"Png loader for tiled images.\"\"\"      def __init__(self, dir: str, paths: list[str]):         \"\"\"Initialize the PngLoader.          Args:             dir (str): Directory where the PNG files are located.             paths (list[str]): List of PNG file paths relative to the directory.         \"\"\"         self.dir = dir         self.paths = paths      def load(self) -&gt; np.ndarray:         \"\"\"Load the PNG files and stack them into a numpy array.\"\"\"         arrays = []         for path in self.paths:             full_path = f\"{self.dir}/{path}\"             img = PIL.Image.open(full_path)             arrays.append(np.array(img))         stacked_arrays = np.stack(arrays, axis=0)[None, None, :, :, :]         return stacked_arrays      @property     def dtype(self):         \"\"\"Return the data type of the loaded images.\"\"\"         return \"uint8\" In\u00a0[5]: Copied! <pre># Aggregate together the tiles metadata\nagg_tiles_meta = tiles_meta.groupby([\"row\", \"column\", \"acquisition_id\", \"fov\"]).agg(\n    list\n)\nagg_tiles_meta\n</pre> # Aggregate together the tiles metadata agg_tiles_meta = tiles_meta.groupby([\"row\", \"column\", \"acquisition_id\", \"fov\"]).agg(     list ) agg_tiles_meta Out[5]: path channel z t pos_x pos_y shape_x shape_y row column acquisition_id fov B 3 0 1 [20200812-CardiomyocyteDifferentiation14-Cycle... [0, 0] [0, 1] [0, 0] [-1448.3, -1448.3] [1517.7, 1517.7] [2560, 2560] [2160, 2160] 2 [20200812-CardiomyocyteDifferentiation14-Cycle... [0, 0] [0, 1] [0, 0] [-1032.3, -1032.3] [1517.7, 1517.7] [2560, 2560] [2160, 2160] In\u00a0[6]: Copied! <pre>from ngio import PixelSize\n\nfrom fractal_converters_tools import OriginDict, Point, Tile\n\npx_size_meta = metadata.get(\"pixel_size\", {})\npixel_size = PixelSize(\n    x=px_size_meta.get(\"x\", 1),\n    y=px_size_meta.get(\"y\", 1),\n    z=px_size_meta.get(\"z\", 1),  # Assuming a constant pixel size in z\n    t=px_size_meta.get(\"t\", 1),  # Assuming a constant pixel size in t\n)\n\nfor tile in agg_tiles_meta.itertuples():\n    # All tiles should have the same pos_x and pos_y\n    # This is a sanity check\n    assert all(tile.pos_x[0] == x for x in tile.pos_x)\n    assert all(tile.pos_y[0] == y for y in tile.pos_y)\n    pos_x, pos_y = tile.pos_x[0], tile.pos_y[0]\n    size_x = tile.shape_x[0] * pixel_size.x\n    size_y = tile.shape_y[0] * pixel_size.y\n\n    # Find top-left corner of the tile\n    min_t, min_z, min_c = min(tile.t), min(tile.z), min(tile.channel)\n    top_left = Point(\n        x=pos_x,\n        y=pos_y,\n        z=min_z,\n        t=min_t,\n        c=min_c,\n    )\n    # Find bottom-right corner of the tile\n    max_t, max_z, max_c = max(tile.t), max(tile.z), max(tile.channel)\n    bottom_right = Point(\n        x=pos_x + size_x,\n        y=pos_y + size_y,\n        t=(max_t + 1) * pixel_size.t,  # +1 because we want to include the last pixel\n        z=(max_z + 1) * pixel_size.z,  # +1 because we want to include the last pixel\n        c=max_c + 1,\n    )\n    # Origin in this case is basically the top-left corner of the tile\n    # But in more complex case can be different\n    # For example t and z should be integer in the Point Object\n    # But here ideally we would like to have the original microscope position\n    origin = OriginDict(\n        x_micrometer_original=pos_x,\n        y_micrometer_original=pos_y,\n        z_micrometer_original=0,\n        t_original=0,\n    )\n\n    # Create a loader object for the tile\n    loader = PngLoader(\"../tests/hiPSC_Tiny/data/\", tile.path)\n\n    tile_obj = Tile.from_points(\n        top_l=top_left,\n        bot_r=bottom_right,\n        pixel_size=PixelSize(\n            x=pixel_size.x, y=pixel_size.y, z=pixel_size.z, t=pixel_size.t\n        ),\n        origin=origin,\n        data_loader=loader,\n    )\n    tiled_image.add_tile(tile_obj)\n</pre> from ngio import PixelSize  from fractal_converters_tools import OriginDict, Point, Tile  px_size_meta = metadata.get(\"pixel_size\", {}) pixel_size = PixelSize(     x=px_size_meta.get(\"x\", 1),     y=px_size_meta.get(\"y\", 1),     z=px_size_meta.get(\"z\", 1),  # Assuming a constant pixel size in z     t=px_size_meta.get(\"t\", 1),  # Assuming a constant pixel size in t )  for tile in agg_tiles_meta.itertuples():     # All tiles should have the same pos_x and pos_y     # This is a sanity check     assert all(tile.pos_x[0] == x for x in tile.pos_x)     assert all(tile.pos_y[0] == y for y in tile.pos_y)     pos_x, pos_y = tile.pos_x[0], tile.pos_y[0]     size_x = tile.shape_x[0] * pixel_size.x     size_y = tile.shape_y[0] * pixel_size.y      # Find top-left corner of the tile     min_t, min_z, min_c = min(tile.t), min(tile.z), min(tile.channel)     top_left = Point(         x=pos_x,         y=pos_y,         z=min_z,         t=min_t,         c=min_c,     )     # Find bottom-right corner of the tile     max_t, max_z, max_c = max(tile.t), max(tile.z), max(tile.channel)     bottom_right = Point(         x=pos_x + size_x,         y=pos_y + size_y,         t=(max_t + 1) * pixel_size.t,  # +1 because we want to include the last pixel         z=(max_z + 1) * pixel_size.z,  # +1 because we want to include the last pixel         c=max_c + 1,     )     # Origin in this case is basically the top-left corner of the tile     # But in more complex case can be different     # For example t and z should be integer in the Point Object     # But here ideally we would like to have the original microscope position     origin = OriginDict(         x_micrometer_original=pos_x,         y_micrometer_original=pos_y,         z_micrometer_original=0,         t_original=0,     )      # Create a loader object for the tile     loader = PngLoader(\"../tests/hiPSC_Tiny/data/\", tile.path)      tile_obj = Tile.from_points(         top_l=top_left,         bot_r=bottom_right,         pixel_size=PixelSize(             x=pixel_size.x, y=pixel_size.y, z=pixel_size.z, t=pixel_size.t         ),         origin=origin,         data_loader=loader,     )     tiled_image.add_tile(tile_obj) In\u00a0[7]: Copied! <pre>from fractal_converters_tools import (\n    AdvancedComputeOptions,\n    build_parallelization_list,\n    initiate_ome_zarr_plates,\n)\n\n# Build parallelization list for the compute phase\nparallelization_list = build_parallelization_list(\n    zarr_dir=\"./test_zarr\",\n    tiled_images=[tiled_image],\n    overwrite=True,\n    advanced_compute_options=AdvancedComputeOptions(),\n)\n\n# Initiate the OME-Zarr plates with the tiled image\ninitiate_ome_zarr_plates(\n    zarr_dir=\"./test_zarr\",\n    tiled_images=[tiled_image],\n    overwrite=True,\n)\n</pre> from fractal_converters_tools import (     AdvancedComputeOptions,     build_parallelization_list,     initiate_ome_zarr_plates, )  # Build parallelization list for the compute phase parallelization_list = build_parallelization_list(     zarr_dir=\"./test_zarr\",     tiled_images=[tiled_image],     overwrite=True,     advanced_compute_options=AdvancedComputeOptions(), )  # Initiate the OME-Zarr plates with the tiled image initiate_ome_zarr_plates(     zarr_dir=\"./test_zarr\",     tiled_images=[tiled_image],     overwrite=True, ) <ul> <li><code>Compute</code> task</li> </ul> In\u00a0[8]: Copied! <pre>from fractal_converters_tools import ConvertParallelInitArgs, generic_compute_task\n\nfor task in parallelization_list:\n    print(f\"Running task: {task}\")\n    generic_compute_task(\n        zarr_url=task[\"zarr_url\"],\n        init_args=ConvertParallelInitArgs(**task[\"init_args\"]),\n    )\n</pre> from fractal_converters_tools import ConvertParallelInitArgs, generic_compute_task  for task in parallelization_list:     print(f\"Running task: {task}\")     generic_compute_task(         zarr_url=task[\"zarr_url\"],         init_args=ConvertParallelInitArgs(**task[\"init_args\"]),     ) <pre>Running task: {'zarr_url': 'test_zarr/hiPSC_Tiny.zarr/B/3/0', 'init_args': {'tiled_image_pickled_path': 'test_zarr/_tmp_converter_dir/6ad1a4c1-d030-442e-b01d-acafcbfd9a29.pkl', 'overwrite': True, 'advanced_compute_options': {'num_levels': 5, 'tiling_mode': 'auto', 'swap_xy': False, 'invert_x': False, 'invert_y': False, 'max_xy_chunk': 4096, 'z_chunk': 10, 'c_chunk': 1, 't_chunk': 1}}}\n</pre> In\u00a0[9]: Copied! <pre>from ngio import open_ome_zarr_plate\n\nplate = open_ome_zarr_plate(\"./test_zarr/hiPSC_Tiny.zarr\")\nplate\n</pre> from ngio import open_ome_zarr_plate  plate = open_ome_zarr_plate(\"./test_zarr/hiPSC_Tiny.zarr\") plate Out[9]: <pre>Plate([rows x columns] (1 x 1))</pre> In\u00a0[10]: Copied! <pre>container = plate.get_image(row=\"B\", column=3, image_path=\"0\")\ncontainer\n</pre> container = plate.get_image(row=\"B\", column=3, image_path=\"0\") container Out[10]: <pre>OmeZarrContainer(levels=5, tables=['well_ROI_table', 'FOV_ROI_table'])</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial/#tutorial","title":"Tutorial\u00b6","text":"<p>In this tutorial, we will walk through the process of creating a simple OME-Zarr converter. For this example we will use this hiPSC 3D Tiny.</p>"},{"location":"tutorial/#step-0-parse-the-necessary-metadata-from-the-raw-data","title":"Step 0: Parse the necessary metadata from the raw data\u00b6","text":"<p>Fractal converters tools does not provide any tooling for this step, since it is highly dependent on the raw data format, instrument, and other factors.</p> <p>In the example dataset we have a single well, with two fields of view and two z-slices.</p> <p>To simplify the tutorial we have already pre-parsed the metadata and saved in:</p> <ul> <li><code>metadata.json</code> file with the global metadata for the dataset, like (pixel size, channel names, etc.).</li> <li><code>data/</code> a directory with the raw data files, which in this case are 4 PNG images (2 fields of view, 2 z-slices).</li> <li><code>tiles.csv</code> file with the metadata for each of the png files.</li> </ul> <p>These files are just an example, can adapt them to whatever format you prefer, as long as you can parse the necessary metadata from the raw data.</p>"},{"location":"tutorial/#step-1-create-the-tiledimage-object","title":"Step 1: Create the TiledImage object\u00b6","text":"<ul> <li>Group together the metadata for each <code>TiledImage</code> object. In this case we have a single <code>TiledImage</code> object, so we can just use the global metadata.</li> <li>Create a <code>TiledImage</code> object with the metadata and the path to the raw data files.</li> </ul>"},{"location":"tutorial/#step-2-create-the-loader-object","title":"Step 2: Create the Loader object\u00b6","text":"<p>We need to create a <code>Loader</code> object to load the raw data files. the <code>Loader</code> object should implement the <code>TileLoader</code> protocol, which defines the interface for loading the tile data.</p> <pre>class TileLoader(Protocol):\n    \"\"\"Tile loader interface.\"\"\"\n\n    def load(self) -&gt; np.ndarray | Array:\n        \"\"\"Load the tile data into a numpy array in the format (t, c, z, y, x).\"\"\"\n        ...\n\n    @property\n        def dtype(self) -&gt; str:\n            \"\"\"Return the dtype of the tile.\"\"\"\n            ...\n</pre>"},{"location":"tutorial/#step-3-add-the-tiles-to-the-tiledimage-object","title":"Step 3: Add the tiles to the TiledImage object\u00b6","text":"<ul> <li>Now we need to add <code>Tiles</code> to our <code>TiledImage</code> object.</li> </ul>"},{"location":"tutorial/#step-2-setup-the-fractal-task","title":"Step 2: Setup the fractal task\u00b6","text":"<ul> <li><code>Init</code> task</li> </ul>"},{"location":"tutorial/#check-the-results","title":"Check the results\u00b6","text":""}]}